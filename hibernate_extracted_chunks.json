{
  "total_chunks": 9,
  "chunks": [
    {
      "id": 1,
      "text": "Développement d’applications Java : POO, Hibernate et JavaFXS4 - ORM et Framework Hibernate\n\n\n--- Page 2 ---\nObjectifs de la séance\n• Comprendre les structures des bases de données\n• Manipuler les données via le Framework Hibernate via JAVA.\n\n--- Page 3 ---\nLes trois dimensions d’une application\n3 Interface Langages de programmation / manipulation de données Stations de travail Traitements Données SGBD Bases de Données\n\n\n--- Page 4 ---\nDéveloppement en couche\nMySQL Oracle SQL Server… JDBCHibernate JPA… Java Swing JAVA FX JSP / Servlet Struts JSF… 4\n\n\n--- Page 5 ---\nDéveloppement en couche\n• Dans cette architecture, nous distinguons :\n• le système de gestion de base de données (SGBD), qui stocke les données utilisées par l'application,\n• la couche d'accès aux données, en charge de l'accès aux données et de leur manipulation, indépendamment du SGBD choisi,\n• la couche métier, gère la logique de l'application,\n• la couche service : correspondant à la mise en œuvre de l'ensemble des règles de gestion et de la logique applicative,\n• la couche présentation, qui s'occupe à la fois d'afficher les données reçues par la couche de services et d'envoyer à la couche de services les informations relatives aux actions de l'utilisateur.\n5\n\n\n--- Page 6 ---\nIntroduction aux bases de données\n6\n\n\n--- Page 7 ---\nBases de données\n7 JAVA-012 : Programmation Orienté Objet - Application au langage JAVA\n« Ensemble structuré de données qui modélisent un univers réel »\nUne Base de données est faite pour enregistrer des faits, des opérations au sein d'un organisme (Ecole, administration, banque, université, hôpital, hôtel,..)\n Les BD ont une place essentielle dans l'informatique.\n\n\n--- Page 8 ---\nSystème de Gestion de Base de Données (SGBD)\n8\n« Système qui permet de gérer des bases de données partagées par plusieurs utilisateurs simultanément »\nDoit permettre de :\n• Décrire les données : indépendamment des applications (DATA DEFINITION LANGUAGE)\n• Manipuler les données : interroger et mettre à jour les données (DATA MANIPULATION LANGUAGE)\n• Contrôler les données : intégrité et confidentialité (DATA CONTROL LANGUAGE)\nRelationnel (SQL) :\n• Données stockées dans des tables (lignes/colonnes).\n• Schéma fixe : chaque ligne suit la même structure.\nNoSQL Document :\n• Données stockées sous forme de documents JSON-like (clé/valeur imbriquées).\n• Schéma flexible : chaque document peut avoir des champs différents.",
      "char_count": 2416,
      "word_count": 387
    },
    {
      "id": 2,
      "text": "Le modèle relationnel\n9\nRef Nom Prix Stock Z12 DELL 5000 10 Z24 SUMSUNG 7000 5 Z26 SONY 8000 20 Id Type Produit quantité Date 1 In Z12 10012/09/2025 2 Out Z24 20220/09/2025 Id Nom email téléphone produit 1 DELL contact@dell.com 0546787623 Z12 2 SUMSUNG contact@sumsung.com 0987654578 Z24 3 SONY contact@sony.com 0876548932 Z26\n\n\n--- Page 10 ---\nLes langages de requête\n10 SQL (Structured Query Language) : SQL est devenu le langage standard pour décrire et manipuler les BDR.\nSQL est l'interface logiciel/logiciel entre les applications et les SGDB\nSQL est un langage déclaratif inventé par IBM dans les années 1970 (projet System R).\n\n\n--- Page 11 ---\nLes langages de requête\n11 Les commandes SQL :\n- De définition de la base de données : CREATE database, DROP database\n- De définition des données pour créer au modifier la structure : CREATE, DROP , ALTER\n- De manipulation des données pour insérer, mettre à jour, supprimer et lire : SELECT, INSERT, UPDATE, DELETE\n- Transactions BEGIN, COMMIT, ROLLBACK",
      "char_count": 1006,
      "word_count": 169
    },
    {
      "id": 3,
      "text": "JAVA-012 : Programmation Orienté Objet - Application au langage JAVA 12\nJava : connexion à une base de données\n\n\n--- Page 13 ---\n• Java DataBase Connectivity (JDBC)\n• Une API Java pour connecter des programmes java à des SGBD.\n• Un ensemble de classes et interfaces java.\n• JDBC va permettre :\n• D'établir une connexion à la BD.\n• D'envoyer des requêtes SQL.\n• De récupérer les résultats des requêtes.\n• Il faut charger un driver pour le SGBD.\n13\nInterface de connexion aux bases de données via une API Java ainsi manipuler des requêtes en réseau. Définition JDBC\n\n\n--- Page 14 ---\nUtilisation du JDBC\n14\nJDBC API (standard, côté Java)\nConnection con = DriverManager.getConnection(url, user, pwd);\nStatement st = con.createStatement();\nResultSet rs = st.executeQuery(\"SELECT * FROM Produit\");\nJDBC Driver (spécifique à chaque SGBD) : fournie par l’éditeur du SGBD (MySQL, Oracle, PostgreSQL…)\nEx : mysql-connector-j-8.0.33.jar\nEx : postgresql-42.7.3.jar\n\n\n--- Page 15 ---\nURL de connexion\n• Afin de localiser la base de données sur le serveur de base de données, il est indispensable de spécifier une adresse de connexion sous la forme d'une URL.\nCes URL commenceront toutes par \"jdbc:\" .\n• Chaque SGBD a un son propre format d’URL.\n• Pour MySQL, l'URL est la suivante : jdbc:mysql://host:port/database.\n● Host : correspond à l'adresse IP du serveur. (localhost)\n● port : port MySQL ou port par défaut. (3306)\n● Database : le nom de la base de données à laquelle on doit se connecter. (magasin)\nè (mysql)\n● login de mot de passe (root, ) è (root, pwd)\n15",
      "char_count": 1554,
      "word_count": 264
    },
    {
      "id": 4,
      "text": "URL de connexion\n16\n\n\n--- Page 17 ---\nNetBeans service\n17\nComment Créer une connexion à une base de données ?\nServeur et port :\nLogin :\nPwd :\nBase de données :\n\n\n--- Page 18 ---\nDB : Exercice\n18\nEn utilisant l’onglet service de Netbeans\n• Créer une base de données « Magasin » create database magasin;\n• Créer la table produit (en se référant à votre classe)\n• Insérer quelques données dans la table (insert)\n• Sélectionner les données (select)\n\n\n--- Page 19 ---\nFramework de persistance (Hibernate)\n19\n\n\n--- Page 20 ---\nIntroduction : DELL Ref=23 nom=DELL prix=5000 Stock = 10 : SUMSUNG Ref=24 nom=SUMSUNG prix=7000 Stock = 5 : SONY Ref=25 nom=SONY prix=8000 Stock = 20 Produit\nBase de données relationnelle\nHibernate est un Framework Java de persistance qui permet de faire correspondre des tables de base de données relationnelles à des objets Java.\nUn programme Java peut manipuler toutes les données en utilisant des JavaBean, masquant ainsi la base de données sous-jacente et ses spécificités.\nLe Framework assure le remplissage de ces objets et la mise à jour de la base en fonction de leur contenu.\n20\n\n\n--- Page 21 ---\nIntroduction\n• Hibernate est un Framework de mapping Objet/Relationnel pour applications JAVA.\n• La technologie de mapping objet/relationnel (ORM) décrit la technique consistant à faire le lien entre la représentation objet des données et la représentation relationnelle basée sur un schéma SQL.\n• Hibernate génère le code SQL :\n• Pas de requête SQL à écrire,\n• Pas d’Objet ResultSet à gérer,\n• Application plus portable. S’adapte à la base de données cible.\n• Hibernate s’occupe du transfert des objets Java dans les tables de la base de données\n• En plus, il permet de requêter les données et propose des moyens de les récupérer.\n• Il peut donc réduire de manière significative le temps de développement qu’il aurait été autrement perdu dans une manipulation manuelle des données via SQL et JDBC.\n21",
      "char_count": 1929,
      "word_count": 330
    },
    {
      "id": 5,
      "text": "Mise en œuvre du Framework Hibernate\n• Une classe de type JavaBean qui encapsule les données d'une table donnée en nommée « classe de persistance » et contenant des annotations.\n• Des propriétés de configuration, notamment des informations concernant la connexion à la base de données (url, login et pwd) contenant les mappages des classes.\nL'architecture d'Hibernate\n22\n\n\n--- Page 23 ---\nFichiers de configuration\nLe fichier hibernate.properties ou Hibernate.cfg.xml sert à configurer l'accès à la base de données.\nLes infos indispensables sont les suivantes :\n• hibernate.connection.driver_class = Le chemin vers le driver JDBC,\n• hibernate.connection.url = Le chemin d'accès à la base,\n• hibernate.connection.username = Le nom de l'utilisateur de la connexion,\n• hibernate.connection.password = Le mot de passe de la connexion,\n23\n\n\n--- Page 24 ---\nFichiers de configuration\n<hibernate-configuration>\n<session-factory>\n<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/ecole</property>\n<property name=\"hibernate.connection.username\">root</property>\n<property name=\"hibernate.connection.password\">root</property>\n<mapping class=\"classes.metiers.Produit\"/>\n</session-factory>\n</hibernate-configuration>\n\n\n--- Page 25 ---\nLes Classes de données\nUne classe de données est un JavaBean qui va encapsuler les propriétés de la table dans ses champs privés mappés avec @ et contient des getters et setters.\n25\n@Id @Basic(Optional=false) @GeneratedValue(strategy= GenerationType.IDENTITY) (« auto-increment ») @Column(name= \"NOM_COLONNE\" , nullable= false, unique = true, length= 100, precision= 10, scale= 2, insertable= true, updatable= true, columnDefinition= \"DECIMAL(10,2)\" , table = \"AUTRE_TABLE\") @Entity cette classe Java correspond à une table relationnelle.\n@Entity(name= \"ProduitEntity\") Si nom non définit, par défaut c’est le nom de la classe.\n@Table(name= \"PRODUITS\" , schema= \"GESTION\" , // schéma de base de données catalog= \"STOCKS\" , // database name uniqueConstraints= {@UniqueConstraint(name= \"UK_PRODUIT_REF\" , columnNames= {\"REF\"})},)",
      "char_count": 2234,
      "word_count": 263
    },
    {
      "id": 6,
      "text": "Manipuler un produit dans la DB\n26\nSessionFactory à partir de la config à c’est une usine qui produit des sessions de connexion à la base de données\nCréation d’un objet Configuration Hibernate.\n• new Configuration() → objet qui représente la config Hibernate.\n• .configure() → charge le fichier hibernate.cfg.xml par défaut (situé dans src/main/resources).\nLa Session Hibernate correspond à une connexion avec la base de données.\nElle permet d’exécuter des transactions et d’interagir avec les entités (insert, update, delete, requêtes…).\nSession.persist(p) à insert\nSession.save(p) à insert (return id)\nSession.update(p) à mettre à jour\nSession.merge(p) à insert ou update\nSession.delete(p) à delete\nSession.remove(p) à delete\nSession.get(class,id) à charge un objet de type class à partir de la base de données. On peut aussi utiliser la od().\n• openSession() → Ouvre une nouvelle session.\n• close() → Ferme la session et libère la connexion JDBC.\n\n\n--- Page 27 ---\nPremière Application\n¡ Préparer le projet :\n§ Au premier lieu, nous avons besoin des librairies Hibernate et de copier les fichiers .jar dans le répertoire lib de votre projet,\n§ Pour travailler avec une base de données MySQL, nous aurons besoin également du connecteur JDBC de MySQL\n27\n\n\n--- Page 28 ---\nExemple d’application\nCréation de la base de données « magasin »\nOn va commencer par créer la table dans la base de données\n28 create database magasin;\nCréation de la table « produit »\nAttention, la table doit avoir une clé primaire",
      "char_count": 1505,
      "word_count": 243
    },
    {
      "id": 7,
      "text": "Configurer Hibernate : Hibernate.cfg.xml\n29\n<hibernate-configuration>\n<session-factory>\n<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/magasin</property>\n<property name=\"hibernate.connection.username\">root</property>\n<property name=\"hibernate.connection.password\">root</property>\n</session-factory>\n</hibernate-configuration>\n\n\n--- Page 30 ---\nClasse Produit\n30\nAttention :\n• annotation\n• Getter & Setter générés\n\n\n--- Page 31 ---\nApplication Test\n• Il est temps de charger et de stocker quelques objets produits, mais d’abord nous devons compléter la configuration avec du code d’infrastructure.\n• Nous devons démarrer Hibernate.\nCet démarrage inclut le chargement de la configuration et la construction d'un objet SessionFactory global et le stocker pour faciliter l'accès dans le code de l'application.\n• Une SessionFactory peut ouvrir des nouvelles Sessions.\n• Une Session représente une unité de travail.\nSessionFactory est un objet global instancié une seule fois.\n31",
      "char_count": 1161,
      "word_count": 121
    },
    {
      "id": 8,
      "text": "Créer la couche service\n32\n\n\n--- Page 33 ---\nCréer des produits dans la méthode main\n33",
      "char_count": 87,
      "word_count": 17
    },
    {
      "id": 9,
      "text": "Après Exécution\n34\n\n\n--- Page 35 ---\nLes autres opérations\n35\n\n\n--- Page 36 ---\nExercice\n36\nDans la méthode main créer un menu et programmer les instructions liées a chaque entrée du menu :\nImplémenter les CRUD (Create, Read, Update et Delete)\n1 : Créer un produit\n2 : Afficher un produit à partir de la référence\n3 : Modifier le stock d’un produit\n4 : Supprimer un produit\n8 : Quitter (System.exit())\n\n\n--- Page 37 ---\nHQL : Hibernate Query Language\n37\nCreateQuery : permet d’exécuter des requêtes HQL, comme du SQL, elle utilise les noms des classes et des attributs.\nList<Produit> produits = session.createQuery(\"FROM Produit p WHERE p.prix> 100\").list();\nsession.createQuery(\"FROM Produit p ORDER BY p.prix ASC\").list();\nsession.createQuery(\"SELECT p.nom, SUM(p.stock) FROM Produit p GROUP BY p.nom\").list();\nsession.createQuery(\"FROM Produit p WHERE p.nom= :nom\").setParameter(\"nom\" , \"DELL\").list();\nsession.createQuery(\"FROM Produit p WHERE p.stock< :stock\").setParameter(\"stock\", 10).list();\n• createQuery(\"FROM Produit\") utilise le nom de la classe, pas la table SQL.\nEt renvoie une liste des objets de type Produit\n• Paramètres → :nom, :prix : on utilise setParameter pour donner les valeurs\n• ORDER BY, GROUP BY, HAVING → fonctionnent comme en SQL.\n• Le SELECT ne renvoie pas des entités, on obtient des tableaux d’objets (Object[]).\n\n\n--- Page 38 ---\nExercice\n38\nDans votre méthode main ajouter un menu 6 pour lister les produits et un menu et programmer les instructions liées a chaque entrée du menu :\n1 : Créer un produit\n2 : Afficher un produit à partir de la référence\n3 : Modifier le stock un produit\n4 : Supprimer un produit\n5 : Lister les produits par ordre de prix\n6 : Lister les produits ayant un stock inférieur à un stock saisi en paramètre\n7 : Lister le nom et le prix des produits ayant un stock supérieur à un stock maximum\n8 : Quitter (System.exit())\n\n\n--- Page 39 ---\nPost Lab & Pré Lab\nPostlab (POO en Java) :\nComment Hibernate gère les clés étrangères ?\nEX : cas de la table mouvementDeStock\nQue veut dire les annotations suivantes :\nPrélab (Gestion des interfaces Graphiques JAVA avec Java FX) :\nXML : définition, structure.\nC’est quoi une interface Graphique ?\nC’est les différents API permettant de créer des interfaces graphiques en JAVA ?\nQuelle est la structure d’un projet JAVAFX ?\nQue contient un fichier FXML ?\nComment lier un fichier FXML avec du code JAVA ?\na) @OneToMany\nb) @ManyToOne\nc) @JoinColumn",
      "char_count": 2442,
      "word_count": 406
    }
  ]
}